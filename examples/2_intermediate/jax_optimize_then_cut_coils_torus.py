#!/usr/bin/env python3
"""JAX-first end-to-end demo: optimize a torus parameter, then solve + cut coils + visualize.

This script demonstrates a typical workflow enabled by JAX:

1) Define an objective that depends on REGCOIL outputs (here: chi2_B at a fixed lambda).
2) Differentiate it automatically through matrix assembly + linear solve.
3) Optimize a geometric parameter (here: the coil minor radius a_coil).
4) Run the standard CLI on the optimized configuration to write a REGCOIL-style netCDF output.
5) Optionally postprocess into figures + ParaView VTK + coil filaments.

Outputs are written under `--out_dir` (ignored by git via `.gitignore`).
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
import time
from pathlib import Path


def _write_regcoil_input(*, path: Path, a_coil: float) -> None:
    txt = f"""! Auto-generated by examples/2_intermediate/jax_optimize_then_cut_coils_torus.py
!
! Run:
!   regcoil_jax --platform cpu --verbose {path.name}
!
&regcoil_nml
  nlambda = 8
  lambda_min = 1e-18
  lambda_max = 1e-8

  ntheta_plasma = 32
  nzeta_plasma  = 32
  ntheta_coil   = 32
  nzeta_coil    = 32

  mpol_potential = 10
  ntor_potential = 10

  geometry_option_plasma = 1
  R0_plasma = 3.0
  a_plasma = 1.0
  nfp_imposed = 1

  geometry_option_coil = 1
  R0_coil = 3.0
  a_coil = {a_coil:.16e}

  net_poloidal_current_amperes = 1.4
  net_toroidal_current_amperes = 0.3

  symmetry_option = 3
  regularization_term_option = "chi2_K"
/
"""
    path.write_text(txt, encoding="utf-8")


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--platform", type=str, default="cpu", choices=["cpu", "gpu"])
    parser.add_argument("--out_dir", type=str, default="examples/2_intermediate/outputs_optimize_then_cut_coils")
    parser.add_argument("--steps", type=int, default=20)
    parser.add_argument("--lr", type=float, default=5e-2)
    parser.add_argument("--lambda", dest="lam", type=float, default=1.0e-10, help="Regularization lambda used inside the optimization objective.")
    parser.add_argument("--no_figures", action="store_true", help="Skip writing matplotlib figures.")
    parser.add_argument("--no_vtk", action="store_true", help="Skip ParaView VTK files in the postprocess step.")
    parser.add_argument("--no_coils", action="store_true", help="Skip coil cutting in the postprocess step.")
    parser.add_argument("--no_fieldlines", action="store_true", help="Skip field line tracing in the postprocess step.")
    args = parser.parse_args()

    # Must be set before importing jax:
    os.environ["JAX_PLATFORM_NAME"] = str(args.platform)
    os.environ.setdefault("JAX_ENABLE_X64", "True")

    import jax
    import jax.numpy as jnp

    jax.config.update("jax_enable_x64", True)
    try:
        jax.config.update("jax_default_matmul_precision", "highest")
    except Exception:
        pass

    from regcoil_jax.build_matrices_jax import build_matrices
    from regcoil_jax.geometry_torus import torus_xyz_and_derivs
    from regcoil_jax.solve_jax import diagnostics, solve_one_lambda

    project_root = Path(__file__).resolve().parents[2]
    out_dir = (project_root / args.out_dir).resolve()
    out_dir.mkdir(parents=True, exist_ok=True)

    # Small-ish grid for quick CPU runs.
    nfp = 1
    ntheta = 24
    nzeta = 24

    # Geometry: simple circular tori.
    R0_plasma = 3.0
    a_plasma = 1.0
    R0_coil = 3.0

    # Current settings (same as the compareToMatlab1 examples).
    net_pol = 1.4
    net_tor = 0.3

    # Potential basis controls the number of unknowns.
    mpol_potential = 8
    ntor_potential = 8
    symmetry_option = 3

    lam = jnp.asarray(float(args.lam))

    def _surface_dict(*, R0: float, a: jnp.ndarray) -> dict:
        theta = (2.0 * jnp.pi) * jnp.arange(ntheta) / ntheta
        zeta = (2.0 * jnp.pi / nfp) * jnp.arange(nzeta) / nzeta
        r, rth, rze, nunit, normN = torus_xyz_and_derivs(theta, zeta, R0, a)
        return dict(nfp=nfp, theta=theta, zeta=zeta, r=r, rth=rth, rze=rze, nunit=nunit, normN=normN)

    def objective(a_coil: jnp.ndarray) -> jnp.ndarray:
        plasma = _surface_dict(R0=R0_plasma, a=jnp.asarray(a_plasma))
        coil = _surface_dict(R0=R0_coil, a=a_coil)

        inputs = dict(
            ntheta_plasma=ntheta,
            nzeta_plasma=nzeta,
            ntheta_coil=ntheta,
            nzeta_coil=nzeta,
            mpol_potential=mpol_potential,
            ntor_potential=ntor_potential,
            symmetry_option=symmetry_option,
            net_poloidal_current_amperes=net_pol,
            net_toroidal_current_amperes=net_tor,
            load_bnorm=False,
        )
        mats = build_matrices(inputs, plasma, coil)
        sol = solve_one_lambda(mats, lam)
        chi2_B, _chi2_K, _max_B, _max_K = diagnostics(mats, sol[None, :])
        return chi2_B[0]

    obj_jit = jax.jit(objective)
    val_and_grad = jax.jit(jax.value_and_grad(objective))

    a0 = 1.7
    a = jnp.asarray(a0)
    _ = obj_jit(a).block_until_ready()  # compile

    t0 = time.time()
    val0 = float(obj_jit(a).block_until_ready())
    t1 = time.time()
    print(f"init: a_coil={float(a):.6f}  chi2_B={val0:.6e}  eval_s={(t1-t0):.3f}")

    hist_a = [float(a)]
    hist_val = [float(val0)]
    hist_grad = [float("nan")]

    lr = float(args.lr)
    for k in range(int(args.steps)):
        val, g = val_and_grad(a)
        a = a - lr * g
        print(f"step {k:02d}: a_coil={float(a):.6f}  chi2_B={float(val):.6e}  dchi2/da={float(g):.6e}")
        hist_a.append(float(a))
        hist_val.append(float(val))
        hist_grad.append(float(g))

    a_opt = float(hist_a[-1])

    # Plot optimization history
    if not args.no_figures:
        try:
            import matplotlib

            matplotlib.use("Agg", force=True)
            import matplotlib.pyplot as plt

            plt.rcParams.update(
                {
                    "figure.dpi": 200,
                    "savefig.dpi": 200,
                    "font.size": 11,
                    "axes.grid": True,
                    "grid.alpha": 0.25,
                    "axes.spines.top": False,
                    "axes.spines.right": False,
                }
            )
            it = list(range(len(hist_val)))

            fig, ax = plt.subplots(figsize=(6.2, 4.2))
            ax.plot(it, hist_val, "-o", label=r"$\\chi_B^2$")
            ax.set_xlabel("iteration")
            ax.set_ylabel(r"$\\chi_B^2$")
            ax.set_title("Autodiff optimization through REGCOIL (toy)")
            ax.legend(loc="best")
            fig.tight_layout()
            fig.savefig(out_dir / "objective_history.png")
            plt.close(fig)

            fig, ax = plt.subplots(figsize=(6.2, 4.2))
            ax.plot(it, hist_a, "-o", label=r"$a_\\mathrm{coil}$")
            ax.set_xlabel("iteration")
            ax.set_ylabel(r"$a_\\mathrm{coil}$")
            ax.set_title("Coil minor radius updates")
            ax.legend(loc="best")
            fig.tight_layout()
            fig.savefig(out_dir / "a_coil_history.png")
            plt.close(fig)
        except Exception:
            pass

    # Run the standard CLI on an auto-generated input file (so we get a REGCOIL-style output netCDF).
    input_path = out_dir / "regcoil_in.torus_optimize_then_cut"
    _write_regcoil_input(path=input_path, a_coil=a_opt)

    cmd = [sys.executable, "-m", "regcoil_jax.cli", "--platform", str(args.platform), "--verbose", str(input_path)]
    print("[optimize->cli] running:", " ".join(cmd))
    subprocess.run(cmd, cwd=str(project_root), check=True)

    # Optional: postprocess into figures + VTK + coils.* (shared script).
    post = project_root / "examples" / "3_advanced" / "postprocess_make_figures_and_vtk.py"
    cmd = [sys.executable, str(post), "--input", str(input_path)]
    if args.no_figures:
        cmd.append("--no_figures")
    if args.no_vtk:
        cmd.append("--no_vtk")
    if args.no_coils:
        cmd.append("--no_coils")
    if args.no_fieldlines:
        cmd.append("--no_fieldlines")
    print("[optimize->postprocess] running:", " ".join(cmd))
    subprocess.run(cmd, cwd=str(project_root), check=True)


if __name__ == "__main__":
    main()

