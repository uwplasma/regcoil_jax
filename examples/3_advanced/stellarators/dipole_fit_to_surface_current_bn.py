#!/usr/bin/env python3
"""Fit a dipole lattice to the REGCOIL surface-current normal field B_sv.

This is a pedagogic "REGCOIL-PM-like" workflow for real VMEC geometries:

1) Run REGCOIL_JAX for a VMEC boundary (wout or input.*).
2) Extract the normal field generated by the continuous surface current:
      B_sv = Bnormal_total - (Bnormal_from_plasma_current + Bnormal_from_net_coil_currents)
3) Place many dipoles near the winding surface.
4) Solve for dipole moments that match B_sv on the plasma surface (ridge LSQ).

This provides a smooth, differentiable "magnet / coillet" approximation of the surface current.
"""

from __future__ import annotations

import argparse
import os
import time
from pathlib import Path

import numpy as np

try:
    import netCDF4  # noqa: F401
except Exception:  # pragma: no cover
    netCDF4 = None


def _setup_matplotlib():
    import matplotlib

    matplotlib.use("Agg", force=True)
    import matplotlib.pyplot as plt

    plt.rcParams.update(
        {
            "figure.dpi": 220,
            "savefig.dpi": 220,
            "font.size": 10,
            "axes.grid": True,
            "grid.alpha": 0.25,
            "axes.spines.top": False,
            "axes.spines.right": False,
        }
    )
    return plt


def main() -> None:
    if netCDF4 is None:  # pragma: no cover
        raise SystemExit("netCDF4 is required for this example (pip install regcoil_jax[viz]).")

    here = Path(__file__).resolve().parent

    ap = argparse.ArgumentParser()
    ap.add_argument("--platform", type=str, default="cpu", choices=["cpu", "gpu"])
    ap.add_argument("--vmec", type=str, required=True, help="Path to VMEC wout_*.nc or input.*")
    ap.add_argument("--case", type=str, default=None)

    ap.add_argument("--ntheta", type=int, default=40)
    ap.add_argument("--nzeta", type=int, default=40)
    ap.add_argument("--separation", type=float, default=0.60)
    ap.add_argument("--mpol_potential", type=int, default=12)
    ap.add_argument("--ntor_potential", type=int, default=12)
    ap.add_argument("--nlambda", type=int, default=8)
    ap.add_argument("--lambda_min", type=float, default=1e-19)
    ap.add_argument("--lambda_max", type=float, default=1e-13)

    ap.add_argument("--dipole_offset", type=float, default=0.20)
    ap.add_argument("--dipole_stride", type=int, default=12)
    ap.add_argument("--l2_moment", type=float, default=1e-10)
    ap.add_argument("--maxiter", type=int, default=200)

    ap.add_argument("--no_figures", action="store_true")
    ap.add_argument("--no_vtk", action="store_true")
    args = ap.parse_args()

    os.environ.setdefault("JAX_ENABLE_X64", "True")
    os.environ.setdefault("JAX_PLATFORM_NAME", args.platform)

    vmec_path = Path(args.vmec).resolve()
    if not vmec_path.exists():
        raise SystemExit(f"Missing VMEC file: {vmec_path}")

    case = args.case
    if case is None:
        case = vmec_path.stem.replace("wout_", "").replace("input.", "")

    out_dir = here / f"outputs_dipole_fit_{case}_{time.strftime('%Y%m%d_%H%M%S')}"
    out_dir.mkdir(parents=True, exist_ok=True)

    vmec_dst = out_dir / vmec_path.name
    if vmec_dst != vmec_path:
        vmec_dst.write_bytes(vmec_path.read_bytes())

    # Build a regcoil input (same style as coil_design_cut_optimize.py).
    input_path = out_dir / f"regcoil_in.{case}_dipole_fit"
    txt = f"""&regcoil_nml
  general_option = 1

  ntheta_plasma = {int(args.ntheta)}
  nzeta_plasma  = {int(args.nzeta)}
  ntheta_coil   = {int(args.ntheta)}
  nzeta_coil    = {int(args.nzeta)}

  mpol_potential = {int(args.mpol_potential)}
  ntor_potential = {int(args.ntor_potential)}

  geometry_option_plasma = 2
  wout_filename = '{vmec_dst.name}'

  geometry_option_coil = 2
  separation = {float(args.separation):.16e}

  nlambda = {int(args.nlambda)}
  lambda_min = {float(args.lambda_min):.16e}
  lambda_max = {float(args.lambda_max):.16e}
/
"""
    input_path.write_text(txt, encoding="utf-8")

    from regcoil_jax.run import run_regcoil

    res = run_regcoil(str(input_path), verbose=True)
    out_nc = Path(res.output_nc)

    ds = netCDF4.Dataset(str(out_nc), "r")
    try:
        nfp = int(ds.variables["nfp"][()])
        lambdas = np.asarray(ds.variables["lambda"][:], dtype=float)
        Btot = np.asarray(ds.variables["Bnormal_total"][:], dtype=float)
        Bplasma = np.asarray(ds.variables["Bnormal_from_plasma_current"][:], dtype=float)
        Bnet = np.asarray(ds.variables["Bnormal_from_net_coil_currents"][:], dtype=float)
        r_plasma = np.asarray(ds.variables["r_plasma"][:], dtype=float)
        r_coil = np.asarray(ds.variables["r_coil"][:], dtype=float)
        zeta_p = np.asarray(ds.variables["zeta_plasma"][:], dtype=float)
    finally:
        ds.close()

    # Choose lambda by minimal RMS(Bn_total).
    rms_B = np.sqrt(np.mean(Btot * Btot, axis=(1, 2)))
    ilam = int(np.argmin(rms_B))
    print(f"[choose] idx={ilam} lambda={lambdas[ilam]:.3e} rms(Bn_total)={rms_B[ilam]:.3e}")

    Bsv = Btot[ilam] - (Bplasma + Bnet)

    nzeta = int(zeta_p.size)
    r_plasma_1 = r_plasma[:nzeta]
    r_coil_1 = r_coil[:nzeta]

    from regcoil_jax.surface_utils import unit_normals_from_r_zt3
    from regcoil_jax.permanent_magnets import place_dipoles_on_winding_surface, solve_dipole_moments_ridge_cg
    from regcoil_jax.dipoles import dipole_bnormal

    n_plasma = unit_normals_from_r_zt3(r_zt3=r_plasma_1)
    points = r_plasma_1.reshape(-1, 3)
    normals_unit = n_plasma.reshape(-1, 3)
    target = Bsv.reshape(-1)

    n_coil = unit_normals_from_r_zt3(r_zt3=r_coil_1)
    dip_pos, _ = place_dipoles_on_winding_surface(
        surface_points=r_coil_1.reshape(-1, 3),
        surface_normals_unit=n_coil.reshape(-1, 3),
        offset=float(args.dipole_offset),
        stride=int(args.dipole_stride),
    )
    sol = solve_dipole_moments_ridge_cg(
        points=points,
        normals_unit=normals_unit,
        dipole_positions=dip_pos,
        target_bnormal=target,
        l2_moment=float(args.l2_moment),
        maxiter=int(args.maxiter),
    )

    pred = np.asarray(dipole_bnormal(points=points, normals_unit=normals_unit, positions=dip_pos, moments=sol.dipole_moments, batch=4096), dtype=float)
    resid = pred - target
    print(f"[residual] RMS={np.sqrt(np.mean(resid*resid)):.3e} max|Bn|={np.max(np.abs(resid)):.3e} dipoles={dip_pos.shape[0]}")

    if not args.no_figures:
        plt = _setup_matplotlib()
        fig_dir = out_dir / "figures"
        fig_dir.mkdir(exist_ok=True)

        fig, ax = plt.subplots(figsize=(6.2, 3.4))
        ax.hist(np.abs(resid), bins=80, alpha=0.85)
        ax.set_xlabel(r"$|B_{\\mathrm{dipole}}\\cdot n - B_{\\mathrm{sv}}\\cdot n|$ [T]")
        ax.set_ylabel("count")
        ax.set_title("Dipole fit residual on plasma surface")
        fig.tight_layout()
        fig.savefig(fig_dir / "residual_hist.png")
        plt.close(fig)

        resid_zt = resid.reshape(nzeta, -1)
        fig, ax = plt.subplots(figsize=(6.6, 3.8))
        im = ax.imshow(resid_zt, origin="lower", aspect="auto")
        ax.set_title("Dipole fit residual BÂ·n on plasma surface")
        ax.set_xlabel("theta index")
        ax.set_ylabel("zeta index")
        fig.colorbar(im, ax=ax, shrink=0.85, label="T")
        fig.tight_layout()
        fig.savefig(fig_dir / "residual_map.png")
        plt.close(fig)

    if not args.no_vtk:
        from regcoil_jax.vtk_io import write_vts_structured_grid, write_vtp_polydata

        vtk_dir = out_dir / "vtk"
        vtk_dir.mkdir(exist_ok=True)
        write_vts_structured_grid(vtk_dir / "plasma_surface.vts", points_zt3=r_plasma_1, point_data={"Bn_residual": resid.reshape(nzeta, -1)})
        write_vts_structured_grid(vtk_dir / "winding_surface.vts", points_zt3=r_coil_1, point_data={})
        write_vtp_polydata(
            vtk_dir / "dipoles.vtp",
            points=dip_pos,
            verts=np.arange(dip_pos.shape[0], dtype=np.int64),
            point_data={"m": sol.dipole_moments},
        )

    print(f"[done] outputs: {out_dir}")


if __name__ == "__main__":
    main()

