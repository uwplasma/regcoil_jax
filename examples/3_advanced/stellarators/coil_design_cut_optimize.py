#!/usr/bin/env python3
"""End-to-end stellarator coil design from a VMEC boundary (wout or input.*).

This example is intended for "real geometry" cases beyond the simple torus demos.
It is compatible with:

- a VMEC `wout_*.nc` file (recommended), or
- a VMEC `input.*` file (boundary only; vacuum-style workflows).

Workflow:
1) Run REGCOIL_JAX on the VMEC plasma boundary and an offset winding surface.
2) Choose a lambda (default: minimize RMS(Bnormal_total) on the plasma surface).
3) Cut discrete filament coils from the winding-surface current potential Φ.
4) Optimize an independent current for each coil so the discrete Biot–Savart model matches
   the target normal field from the continuous surface current (B_sv).
5) Write publication-ready figures and ParaView outputs (surfaces, coils, residual B·n).

Notes:
- Coil cutting is geometric and non-differentiable. The per-coil current optimization is
  differentiable (autodiff through Biot–Savart).
- This script keeps defaults intentionally modest so it runs in a few minutes on CPU.
"""

from __future__ import annotations

import argparse
import os
import time
from pathlib import Path

import numpy as np

try:
    import netCDF4  # noqa: F401
except Exception:  # pragma: no cover
    netCDF4 = None


def _setup_matplotlib():
    import matplotlib

    matplotlib.use("Agg", force=True)
    import matplotlib.pyplot as plt

    plt.rcParams.update(
        {
            "figure.dpi": 220,
            "savefig.dpi": 220,
            "font.size": 10,
            "axes.grid": True,
            "grid.alpha": 0.25,
            "axes.spines.top": False,
            "axes.spines.right": False,
        }
    )
    return plt


def _write_regcoil_namelist(
    path: Path,
    *,
    vmec_filename: str,
    ntheta: int,
    nzeta: int,
    mpol_potential: int,
    ntor_potential: int,
    separation: float,
    nlambda: int,
    lambda_min: float,
    lambda_max: float,
):
    txt = f"""! Auto-generated by coil_design_cut_optimize.py

&regcoil_nml
  general_option = 1

  ntheta_plasma = {int(ntheta)}
  nzeta_plasma  = {int(nzeta)}
  ntheta_coil   = {int(ntheta)}
  nzeta_coil    = {int(nzeta)}

  mpol_potential = {int(mpol_potential)}
  ntor_potential = {int(ntor_potential)}

  geometry_option_plasma = 2
  wout_filename = '{vmec_filename}'

  geometry_option_coil = 2
  separation = {float(separation):.16e}

  nlambda = {int(nlambda)}
  lambda_min = {float(lambda_min):.16e}
  lambda_max = {float(lambda_max):.16e}
/
"""
    path.write_text(txt, encoding="utf-8")


def main() -> None:
    if netCDF4 is None:  # pragma: no cover
        raise SystemExit("netCDF4 is required for this example (pip install regcoil_jax[viz]).")

    here = Path(__file__).resolve()
    examples_dir = here.parents[2]

    ap = argparse.ArgumentParser()
    ap.add_argument("--platform", type=str, default="cpu", choices=["cpu", "gpu"])
    ap.add_argument("--vmec", type=str, required=True, help="Path to VMEC wout_*.nc or input.*")
    ap.add_argument("--case", type=str, default=None, help="Name used for output folder and filenames.")

    ap.add_argument("--ntheta", type=int, default=48)
    ap.add_argument("--nzeta", type=int, default=48)
    ap.add_argument("--mpol_potential", type=int, default=12)
    ap.add_argument("--ntor_potential", type=int, default=12)
    ap.add_argument("--separation", type=float, default=0.60)

    ap.add_argument("--nlambda", type=int, default=10)
    ap.add_argument("--lambda_min", type=float, default=1e-19)
    ap.add_argument("--lambda_max", type=float, default=1e-13)

    ap.add_argument("--coils_per_half_period", type=int, default=6)
    ap.add_argument("--theta_shift", type=int, default=0)

    ap.add_argument("--current_opt_steps", type=int, default=250)
    ap.add_argument("--current_opt_lr", type=float, default=2e-2)
    ap.add_argument("--seg_batch", type=int, default=2048)

    ap.add_argument("--no_figures", action="store_true")
    ap.add_argument("--no_vtk", action="store_true")
    args = ap.parse_args()

    os.environ.setdefault("JAX_ENABLE_X64", "True")
    os.environ.setdefault("JAX_PLATFORM_NAME", args.platform)

    vmec_path = Path(args.vmec).resolve()
    if not vmec_path.exists():
        raise SystemExit(f"Missing VMEC file: {vmec_path}")

    case = args.case
    if case is None:
        case = vmec_path.stem.replace("wout_", "").replace("input.", "")

    out_dir = here.parent / f"outputs_{case}_{time.strftime('%Y%m%d_%H%M%S')}"
    out_dir.mkdir(parents=True, exist_ok=True)

    # Copy VMEC file into output directory so everything is self-contained.
    vmec_dst = out_dir / vmec_path.name
    if vmec_dst != vmec_path:
        vmec_dst.write_bytes(vmec_path.read_bytes())

    # Write a regcoil input next to the VMEC file and run.
    input_path = out_dir / f"regcoil_in.{case}"
    _write_regcoil_namelist(
        input_path,
        vmec_filename=vmec_dst.name,
        ntheta=int(args.ntheta),
        nzeta=int(args.nzeta),
        mpol_potential=int(args.mpol_potential),
        ntor_potential=int(args.ntor_potential),
        separation=float(args.separation),
        nlambda=int(args.nlambda),
        lambda_min=float(args.lambda_min),
        lambda_max=float(args.lambda_max),
    )

    from regcoil_jax.run import run_regcoil

    res = run_regcoil(str(input_path), verbose=True)
    out_nc = Path(res.output_nc)

    # Read relevant arrays.
    ds = netCDF4.Dataset(str(out_nc), "r")
    try:
        nfp = int(ds.variables["nfp"][()])
        net_pol = float(ds.variables["net_poloidal_current_Amperes"][()])
        lambdas = np.asarray(ds.variables["lambda"][:], dtype=float)
        chi2_B = np.asarray(ds.variables["chi2_B"][:], dtype=float)
        chi2_K = np.asarray(ds.variables["chi2_K"][:], dtype=float)
        Btot = np.asarray(ds.variables["Bnormal_total"][:], dtype=float)  # (nlambda,nzeta,ntheta)
        Bplasma = np.asarray(ds.variables["Bnormal_from_plasma_current"][:], dtype=float)
        Bnet = np.asarray(ds.variables["Bnormal_from_net_coil_currents"][:], dtype=float)
        Phi = np.asarray(ds.variables["current_potential"][:], dtype=float)  # (nlambda,nzeta_coil,ntheta_coil)

        theta_p = np.asarray(ds.variables["theta_plasma"][:], dtype=float)
        zeta_p = np.asarray(ds.variables["zeta_plasma"][:], dtype=float)
        theta_c = np.asarray(ds.variables["theta_coil"][:], dtype=float)
        zeta_c = np.asarray(ds.variables["zeta_coil"][:], dtype=float)
        r_coil = np.asarray(ds.variables["r_coil"][:], dtype=float)  # (nzetal,ntheta,3)
        r_plasma = np.asarray(ds.variables["r_plasma"][:], dtype=float)  # (nzetal,ntheta,3)
    finally:
        ds.close()

    # Choose lambda: minimize RMS(Bnormal_total) on plasma surface.
    area_plasma = (2.0 * np.pi / float(nfp)) * (2.0 * np.pi)  # rough; used only for printing
    rms_B = np.sqrt(np.mean(Btot * Btot, axis=(1, 2)))
    ilam = int(np.argmin(rms_B))
    print(f"[choose] idx={ilam} lambda={lambdas[ilam]:.3e} rms(Bn_total)={rms_B[ilam]:.3e}")

    # Surface-current target normal field B_sv for that lambda.
    Bsv = Btot[ilam] - (Bplasma + Bnet)  # (nzeta,ntheta)

    # Plasma points/normals for Biot–Savart evaluation on a single field period.
    from regcoil_jax.surface_utils import unit_normals_from_r_zt3

    nzeta = int(zeta_p.size)
    r_plasma_1 = r_plasma[:nzeta]
    nunit_1 = unit_normals_from_r_zt3(r_zt3=r_plasma_1)
    points = r_plasma_1.reshape(-1, 3)
    normals_unit = nunit_1.reshape(-1, 3)
    target_bnormal = Bsv.reshape(-1)

    # Cut coils and optimize per-coil currents.
    from regcoil_jax.coil_cutting import cut_coils_from_current_potential, write_makecoil_filaments
    from regcoil_jax.biot_savart_jax import segments_from_filaments, bnormal_from_segments
    from regcoil_jax.coil_current_optimization import optimize_coil_currents_to_match_bnormal

    coils = cut_coils_from_current_potential(
        current_potential_zt=Phi[ilam],
        theta=theta_c,
        zeta=zeta_c,
        r_coil_zt3_full=r_coil,
        theta_shift=int(args.theta_shift),
        coils_per_half_period=int(args.coils_per_half_period),
        nfp=int(nfp),
        net_poloidal_current_Amperes=float(net_pol),
    )
    segs = segments_from_filaments(filaments_xyz=coils.filaments_xyz)
    I0 = coils.coil_currents
    net_target = float(np.sum(I0))

    opt = optimize_coil_currents_to_match_bnormal(
        segs,
        points=points,
        normals_unit=normals_unit,
        target_bnormal=target_bnormal,
        coil_currents0=I0,
        steps=int(args.current_opt_steps),
        lr=float(args.current_opt_lr),
        net_current_target=net_target,
        seg_batch=int(args.seg_batch),
    )
    I1 = opt.coil_currents

    # Final residual on the plasma surface from the discrete coils.
    bn_coils = np.asarray(
        bnormal_from_segments(segs, points=points, normals_unit=normals_unit, filament_currents=I1, seg_batch=int(args.seg_batch)),
        dtype=float,
    )
    resid = (Bplasma + Bnet).reshape(-1) + bn_coils
    print(f"[residual] RMS={np.sqrt(np.mean(resid*resid)):.3e}  max|Bn|={np.max(np.abs(resid)):.3e}")

    write_makecoil_filaments(out_dir / f"coils_initial.{case}", filaments_xyz=coils.filaments_xyz, coil_currents=I0, nfp=int(nfp))
    write_makecoil_filaments(out_dir / f"coils_optimized.{case}", filaments_xyz=coils.filaments_xyz, coil_currents=I1, nfp=int(nfp))

    # Figures
    if not args.no_figures:
        plt = _setup_matplotlib()
        fig_dir = out_dir / "figures"
        fig_dir.mkdir(exist_ok=True)

        fig, ax = plt.subplots(figsize=(6.2, 3.6))
        ax.loglog(chi2_K, chi2_B, "o-", ms=3)
        ax.plot([chi2_K[ilam]], [chi2_B[ilam]], "ro", ms=6, label="chosen")
        ax.set_xlabel(r"$\\chi^2_K$")
        ax.set_ylabel(r"$\\chi^2_B$")
        ax.set_title("REGCOIL tradeoff curve")
        ax.legend(loc="best")
        fig.tight_layout()
        fig.savefig(fig_dir / "tradeoff.png")
        plt.close(fig)

        fig, ax = plt.subplots(figsize=(6.2, 3.4))
        ax.plot(np.asarray(opt.loss_history), "-k")
        ax.set_xlabel("Adam step")
        ax.set_ylabel("loss (MSE + penalties)")
        ax.set_title("Per-coil current optimization")
        fig.tight_layout()
        fig.savefig(fig_dir / "current_opt_loss.png")
        plt.close(fig)

        resid_zt = resid.reshape(nzeta, -1)
        fig, ax = plt.subplots(figsize=(6.6, 3.8))
        im = ax.imshow(resid_zt, origin="lower", aspect="auto")
        ax.set_title(r"$B_{\\mathrm{total}}\\cdot n$ from discrete coils [T]")
        ax.set_xlabel("theta index")
        ax.set_ylabel("zeta index")
        fig.colorbar(im, ax=ax, shrink=0.85, label="T")
        fig.tight_layout()
        fig.savefig(fig_dir / "bn_residual_map.png")
        plt.close(fig)

    # ParaView
    if not args.no_vtk:
        from regcoil_jax.vtk_io import write_vts_structured_grid, write_vtp_polydata

        vtk_dir = out_dir / "vtk"
        vtk_dir.mkdir(exist_ok=True)

        # Surfaces: first field period
        write_vts_structured_grid(vtk_dir / "plasma_surface.vts", points_zt3=r_plasma_1, point_data={"Bn_residual": resid.reshape(nzeta, -1)})
        write_vts_structured_grid(vtk_dir / "winding_surface.vts", points_zt3=r_coil[:nzeta], point_data={})

        # Coils
        pts_all = np.concatenate(coils.filaments_xyz, axis=0)
        conn = []
        off = 0
        for ln in coils.filaments_xyz:
            n = int(ln.shape[0])
            conn.append(list(range(off, off + n)))
            off += n
        write_vtp_polydata(vtk_dir / "coils.vtp", points=pts_all, lines=conn)

    print(f"[done] outputs: {out_dir}")


if __name__ == "__main__":
    main()

