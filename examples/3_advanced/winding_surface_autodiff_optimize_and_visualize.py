#!/usr/bin/env python3
"""Autodiff winding-surface optimization (separation field) + before/after visualization.

This script:
  1) optimizes a spatially-varying offset separation field sep(θ,ζ) using JAX autodiff
  2) writes baseline/optimized winding surfaces as NESCOIL `nescin` files
  3) runs `regcoil_jax` for *before* and *after* surfaces
  4) generates publication-ready figures and ParaView `.vtp/.vts` outputs for both

Outputs are written to an `examples/**/outputs_*` directory (gitignored).
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
import time
from pathlib import Path

import numpy as np

try:
    import netCDF4
except Exception:  # pragma: no cover
    netCDF4 = None


def _setup_matplotlib():
    import matplotlib

    matplotlib.use("Agg", force=True)
    import matplotlib.pyplot as plt

    plt.rcParams.update(
        {
            "figure.dpi": 200,
            "savefig.dpi": 200,
            "font.size": 11,
            "axes.grid": True,
            "grid.alpha": 0.25,
            "axes.spines.top": False,
            "axes.spines.right": False,
        }
    )
    return plt


def _write_regcoil_input(
    path: Path,
    *,
    wout_filename: str,
    nescin_filename: str,
    ntheta: int,
    nzeta: int,
    nlambda: int,
    lambda_min: float,
    lambda_max: float,
    mpol_potential: int,
    ntor_potential: int,
):
    txt = f"""! Autogenerated by {Path(__file__).name}
&regcoil_nml
  general_option = 1

  nlambda = {nlambda}
  lambda_min = {lambda_min:.6e}
  lambda_max = {lambda_max:.6e}

  ntheta_plasma = {ntheta}
  nzeta_plasma  = {nzeta}
  ntheta_coil   = {ntheta}
  nzeta_coil    = {nzeta}

  mpol_potential = {mpol_potential}
  ntor_potential = {ntor_potential}

  geometry_option_plasma = 2
  wout_filename = '{wout_filename}'

  geometry_option_coil = 3
  nescin_filename = '{nescin_filename}'

  save_level = 2
/
"""
    path.write_text(txt, encoding="utf-8")


def _run(cmd: list[str], *, cwd: Path):
    print("[run]", " ".join(cmd), flush=True)
    subprocess.run(cmd, cwd=str(cwd), check=True)


def _read_scalar_arrays(nc_path: Path) -> dict[str, np.ndarray]:
    if netCDF4 is None:  # pragma: no cover
        raise RuntimeError("netCDF4 is required to read netCDF output")
    ds = netCDF4.Dataset(str(nc_path), "r")
    try:
        out = {}
        for k in ("lambda", "chi2_B", "chi2_K", "max_Bnormal", "max_K"):
            out[k] = np.array(ds.variables[k][:], dtype=float)
        return out
    finally:
        ds.close()


def main() -> None:
    here = Path(__file__).resolve()
    repo_root = here.parents[2]
    examples_dir = here.parent

    ap = argparse.ArgumentParser()
    ap.add_argument("--platform", type=str, default="cpu", choices=["cpu", "gpu"])
    ap.add_argument("--wout", type=str, default=str(examples_dir / "wout_d23p4_tm.nc"))
    ap.add_argument("--out_dir", type=str, default=None, help="Output directory (default: outputs_winding_surface_autodiff_<timestamp>)")

    # Optimization settings (small by default so this runs on CPU).
    ap.add_argument("--opt_ntheta", type=int, default=16)
    ap.add_argument("--opt_nzeta", type=int, default=16)
    ap.add_argument("--opt_steps", type=int, default=30)
    ap.add_argument("--opt_step_size", type=float, default=0.05)
    ap.add_argument("--opt_mpol_sep", type=int, default=3)
    ap.add_argument("--opt_ntor_sep", type=int, default=3)
    ap.add_argument("--separation0", type=float, default=0.5)
    ap.add_argument("--separation_min", type=float, default=0.05)
    ap.add_argument("--lambda", dest="lam", type=float, default=1.0e-14)

    # Evaluation settings (for before/after regcoil runs + visualization).
    ap.add_argument("--eval_ntheta", type=int, default=64)
    ap.add_argument("--eval_nzeta", type=int, default=64)
    ap.add_argument("--eval_nlambda", type=int, default=8)
    ap.add_argument("--eval_lambda_min", type=float, default=1.0e-19)
    ap.add_argument("--eval_lambda_max", type=float, default=1.0e-13)
    ap.add_argument("--mpol_potential", type=int, default=12)
    ap.add_argument("--ntor_potential", type=int, default=12)

    args = ap.parse_args()

    # Enable x64 for the in-process autodiff optimization (parity + stability).
    os.environ.setdefault("JAX_ENABLE_X64", "True")

    wout_src = Path(args.wout).resolve()
    if not wout_src.exists():
        raise SystemExit(f"Missing wout file: {wout_src}")

    if args.out_dir is None:
        stamp = time.strftime("%Y%m%d_%H%M%S")
        out_dir = examples_dir / f"outputs_winding_surface_autodiff_{stamp}"
    else:
        out_dir = Path(args.out_dir).resolve()
    out_dir.mkdir(parents=True, exist_ok=True)

    # Copy required inputs into the run directory so the namelist can reference local filenames.
    wout_dst = out_dir / wout_src.name
    if wout_src != wout_dst:
        wout_dst.write_bytes(wout_src.read_bytes())

    from regcoil_jax.winding_surface_optimization import (
        SeparationFieldOptConfig,
        optimize_vmec_offset_separation_field,
        write_optimized_winding_surface_nescin,
    )

    cfg = SeparationFieldOptConfig(
        mpol_sep=int(args.opt_mpol_sep),
        ntor_sep=int(args.opt_ntor_sep),
        separation_min=float(args.separation_min),
    )

    print("[opt] optimizing sep(θ,ζ) ...", flush=True)
    res = optimize_vmec_offset_separation_field(
        wout_filename=str(wout_dst),
        separation0=float(args.separation0),
        nsteps=int(args.opt_steps),
        step_size=float(args.opt_step_size),
        ntheta=int(args.opt_ntheta),
        nzeta=int(args.opt_nzeta),
        mpol_potential=min(int(args.mpol_potential), 6),
        ntor_potential=min(int(args.ntor_potential), 6),
        lam=float(args.lam),
        config=cfg,
    )

    # Write baseline and optimized winding surfaces as nescin files at evaluation resolution.
    nmodes = int(res.coeff_sin_history.shape[1])
    base0 = float(res.base_history[0])
    cs0 = res.coeff_sin_history[0]
    cc0 = res.coeff_cos_history[0]
    basef = float(res.base_history[-1])
    csf = res.coeff_sin_history[-1]
    ccf = res.coeff_cos_history[-1]

    nescin_before = out_dir / "nescin.winding_surface_autodiff_before"
    nescin_after = out_dir / "nescin.winding_surface_autodiff_after"

    write_optimized_winding_surface_nescin(
        path=str(nescin_before),
        wout_filename=str(wout_dst),
        base=base0,
        coeff_sin=cs0,
        coeff_cos=cc0,
        config=cfg,
        ntheta=int(args.eval_ntheta),
        nzeta=int(args.eval_nzeta),
    )
    write_optimized_winding_surface_nescin(
        path=str(nescin_after),
        wout_filename=str(wout_dst),
        base=basef,
        coeff_sin=csf,
        coeff_cos=ccf,
        config=cfg,
        ntheta=int(args.eval_ntheta),
        nzeta=int(args.eval_nzeta),
    )

    # Write two regcoil inputs that point to the respective nescin files.
    in_before = out_dir / "regcoil_in.winding_surface_autodiff_before"
    in_after = out_dir / "regcoil_in.winding_surface_autodiff_after"

    _write_regcoil_input(
        in_before,
        wout_filename=wout_dst.name,
        nescin_filename=nescin_before.name,
        ntheta=int(args.eval_ntheta),
        nzeta=int(args.eval_nzeta),
        nlambda=int(args.eval_nlambda),
        lambda_min=float(args.eval_lambda_min),
        lambda_max=float(args.eval_lambda_max),
        mpol_potential=int(args.mpol_potential),
        ntor_potential=int(args.ntor_potential),
    )
    _write_regcoil_input(
        in_after,
        wout_filename=wout_dst.name,
        nescin_filename=nescin_after.name,
        ntheta=int(args.eval_ntheta),
        nzeta=int(args.eval_nzeta),
        nlambda=int(args.eval_nlambda),
        lambda_min=float(args.eval_lambda_min),
        lambda_max=float(args.eval_lambda_max),
        mpol_potential=int(args.mpol_potential),
        ntor_potential=int(args.ntor_potential),
    )

    # Run regcoil_jax for before/after.
    env = os.environ.copy()
    env.setdefault("JAX_ENABLE_X64", "True")
    env.setdefault("JAX_PLATFORM_NAME", args.platform)
    env.setdefault("JAX_TRACEBACK_FILTERING", "off")

    _run([sys.executable, "-m", "regcoil_jax.cli", "--platform", args.platform, "--verbose", str(in_before)], cwd=repo_root)
    _run([sys.executable, "-m", "regcoil_jax.cli", "--platform", args.platform, "--verbose", str(in_after)], cwd=repo_root)

    out_before = out_dir / "regcoil_out.winding_surface_autodiff_before.nc"
    out_after = out_dir / "regcoil_out.winding_surface_autodiff_after.nc"

    # Postprocess both runs into figures + ParaView files.
    post = repo_root / "examples" / "3_advanced" / "postprocess_make_figures_and_vtk.py"
    _run([sys.executable, str(post), "--input", str(in_before)], cwd=repo_root)
    _run([sys.executable, str(post), "--input", str(in_after)], cwd=repo_root)

    # ----------------------------
    # Additional publication-ready figures: optimization history + before/after overlay
    # ----------------------------
    if netCDF4 is not None:
        plt = _setup_matplotlib()
        fig_dir = out_dir / "figures_compare"
        fig_dir.mkdir(exist_ok=True)

        t = np.arange(res.objective_history.shape[0])
        obj = np.array(res.objective_history, dtype=float)

        fig, ax = plt.subplots(figsize=(6.6, 4.2))
        ax.plot(t, obj, "-o", ms=3)
        ax.set_xlabel("Optimization step")
        ax.set_ylabel("Objective")
        ax.set_title("Autodiff winding-surface optimization (separation field)")
        fig.tight_layout()
        fig.savefig(fig_dir / "optimization_objective.png")
        plt.close(fig)

        A = _read_scalar_arrays(out_before)
        B = _read_scalar_arrays(out_after)

        fig, ax = plt.subplots(figsize=(6.6, 4.2))
        ax.semilogx(A["lambda"], A["max_K"], "-o", ms=3, label="before: max|K|")
        ax.semilogx(B["lambda"], B["max_K"], "-o", ms=3, label="after:  max|K|")
        ax2 = ax.twinx()
        ax2.semilogx(A["lambda"], A["max_Bnormal"], "--s", ms=3, color="C2", label="before: max|B_n|")
        ax2.semilogx(B["lambda"], B["max_Bnormal"], "--s", ms=3, color="C3", label="after:  max|B_n|")
        ax.set_xlabel(r"$\lambda$")
        ax.set_ylabel(r"$\max |K|$")
        ax2.set_ylabel(r"$\max |B_n|$")
        h1, l1 = ax.get_legend_handles_labels()
        h2, l2 = ax2.get_legend_handles_labels()
        ax.legend(h1 + h2, l1 + l2, loc="best")
        ax.set_title("Before/after REGCOIL diagnostics (lambda scan)")
        fig.tight_layout()
        fig.savefig(fig_dir / "before_after_lambda_scan.png")
        plt.close(fig)

    print("\nOutputs:")
    print(f"  - {out_dir}")
    print("ParaView:")
    print("  Open both before/after VTK directories, e.g.:")
    print(f"    - {out_dir / 'vtk_winding_surface_autodiff_before' / 'coil_surface.vtp'}")
    print(f"    - {out_dir / 'vtk_winding_surface_autodiff_after' / 'coil_surface.vtp'}")
    print("  Color by 'Kmag' or 'Phi' and compare before vs after.")


if __name__ == "__main__":
    main()
